// OSA Community Platform - Database Schema
// This schema follows the specification in prompts/02_DATABASE_SCHEMA.md

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // For migrations (bypasses connection pooling)
}

generator client {
  provider = "prisma-client-js"
}

// ============================================================================
// ENUMS
// ============================================================================

enum UserRole {
  GUEST       // Can view public content only
  MEMBER      // Can register for events, manage profile
  CONTRIBUTOR // Can create/edit content
  ADMIN       // Full access
}

enum MembershipStatus {
  PENDING   // Awaiting payment
  ACTIVE    // Paid and valid
  EXPIRED   // Past expiry date
  CANCELLED // User/admin cancelled
  UPGRADED  // Replaced by a newer membership
}

enum RegistrationStatus {
  PENDING   // Awaiting payment (paid events)
  CONFIRMED // Seat secured
  CANCELLED // User/admin cancelled
  COMPLETED // Event ended (historical)
}

enum WaitlistStatus {
  WAITING  // In queue
  OFFERED  // Spot available, email sent
  ACCEPTED // User accepted, moved to registration
  EXPIRED  // Didn't respond in time
  DECLINED // User declined the spot
}

enum PaymentType {
  MEMBERSHIP         // One-time membership payment
  EVENT_ONETIME      // Single event registration
  EVENT_SUBSCRIPTION // Recurring event subscription
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

// ============================================================================
// USER DOMAIN
// ============================================================================

/// Core user model - linked to Supabase Auth
model User {
  id        String    @id // Matches Supabase Auth UUID exactly
  email     String    @unique
  role      UserRole  @default(GUEST)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // GDPR soft delete - never hard delete users

  // Relations
  profile             Profile?
  memberships         Membership[]        @relation("UserMemberships")
  eventRegistrations  EventRegistration[]
  waitlistEntries     WaitlistEntry[]
  authoredArticles    Article[]           @relation("AuthoredArticles")
  createdEvents       Event[]             @relation("CreatedEvents")
  createdPages        StaticPage[]        @relation("CreatedPages")
  payments            Payment[]
  performedAuditLogs  AuditLog[]          @relation("PerformedByUser")
  approvedMemberships Membership[]        @relation("ApprovedByAdmin")
  uploadedMedia       Media[]             @relation("UploadedByUser")

  @@index([email])
  @@index([role])
  @@index([deletedAt])
  @@map("users")
}

/// Extended user profile information
model Profile {
  id         String   @id @default(uuid())
  userId     String   @unique
  firstName  String
  lastName   String
  spouseName String?
  children   Json?    // Array: [{name: "Child1", age: 10, gender: "M"}]
  address    Json     // Object: {street, city, state, zip, country}
  phone      String?
  avatarUrl  String?
  bio        String?  @db.Text
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

// ============================================================================
// MEMBERSHIP DOMAIN
// ============================================================================

/// Available membership tiers (managed by admin)
model MembershipType {
  id             String   @id @default(uuid())
  name           String   @unique // "Gold", "Silver", "Lifetime", "Student"
  slug           String   @unique // "gold", "silver", "lifetime", "student"
  description    String?  @db.Text
  price          Decimal  @db.Decimal(10, 2)
  benefits       Json?    // Array: ["Benefit 1", "Benefit 2", "Benefit 3"]
  durationMonths Int?     // null = lifetime, otherwise number of months
  isActive       Boolean  @default(true)
  sortOrder      Int      @default(0) // For display ordering
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  memberships Membership[]

  @@index([isActive, sortOrder])
  @@map("membership_types")
}

/// User membership record
model Membership {
  id               String           @id @default(uuid())
  userId           String
  membershipTypeId String
  status           MembershipStatus @default(PENDING)
  startDate        DateTime?
  expiryDate       DateTime?

  // Payment tracking
  lastPaymentId    String? // Reference to Payment record
  stripeCustomerId String? // For recurring (future use)

  // Admin approval (for offline payments only)
  approvedById String? // Admin user ID
  approvedAt   DateTime?
  approvalNote String?  @db.Text // "Paid via check #1234"

  // Upgrade tracking (for historical records)
  upgradedFromId String?      @unique // Points to previous membership that was upgraded
  upgradedToId   String?      @unique // Points to new membership after upgrade

  // Credit tracking (for memberships purchased with credit from expired membership)
  creditAppliedFromId String?  @unique // ID of expired membership whose payment was credited
  creditAmount        Decimal? @db.Decimal(10, 2) // Amount of credit applied from expired membership

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user           User           @relation("UserMemberships", fields: [userId], references: [id], onDelete: Cascade)
  membershipType MembershipType @relation(fields: [membershipTypeId], references: [id])
  approvedBy     User?          @relation("ApprovedByAdmin", fields: [approvedById], references: [id])
  upgradedFrom   Membership?    @relation("UpgradedFrom", fields: [upgradedFromId], references: [id], onDelete: SetNull)
  upgradedTo     Membership?    @relation("UpgradedFrom")
  creditAppliedFrom Membership? @relation("CreditApplied", fields: [creditAppliedFromId], references: [id], onDelete: SetNull)
  creditUsedIn   Membership?    @relation("CreditApplied")

  @@index([userId])
  @@index([status])
  @@index([expiryDate])
  @@index([userId, status]) // Composite index for finding user's active membership
  @@map("memberships")
}

// ============================================================================
// EVENT DOMAIN
// ============================================================================

/// Event categories (seeded, managed by admin)
model EventCategory {
  id          String   @id @default(uuid())
  name        String   @unique // "Education", "Cultural", etc.
  slug        String   @unique // "education", "cultural", etc.
  description String?  @db.Text
  color       String?  // Hex color for UI badges: "#3B82F6"
  icon        String?  // Lucide icon name: "GraduationCap"
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  events Event[]

  @@index([isActive, sortOrder])
  @@map("event_categories")
}

/// Event model
model Event {
  id                   String    @id @default(uuid())
  title                String
  slug                 String    @unique
  excerpt              String?   @db.VarChar(500) // Short description for listings
  content              String    @db.Text // TipTap HTML with embedded images
  categoryId           String
  // Scheduling
  startDate            DateTime
  endDate              DateTime?
  registrationDeadline DateTime?

  // Capacity management
  maxSeats     Int
  currentSeats Int @default(0) // Managed by database trigger

  // Location
  location        String?
  locationDetails Json?   // {address, city, state, zip, coordinates}
  isVirtual       Boolean @default(false)
  virtualLink     String? // Zoom/Meet link (shown only to registered users)

  // Payment
  isFree            Boolean @default(true)
  price             Decimal? @db.Decimal(10, 2)
  isRecurring       Boolean @default(false)
  recurringInterval String? // "weekly", "monthly"
  stripePriceId     String? // Stripe Price ID for recurring

  // Media
  featuredImage String? // Supabase Storage URL
  gallery       Json? // Array of image URLs

  // Status
  status      String    @default("DRAFT") // DRAFT, PUBLISHED, CANCELLED, COMPLETED
  isActive    Boolean   @default(true)
  publishedAt DateTime?

  // Audit
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  category      EventCategory       @relation(fields: [categoryId], references: [id])
  createdBy     User                @relation("CreatedEvents", fields: [createdById], references: [id])
  registrations EventRegistration[]
  waitlist      WaitlistEntry[]

  @@index([status, startDate])
  @@index([categoryId])
  @@index([isActive])
  @@index([slug])
  @@map("events")
}

/// Event registration record
model EventRegistration {
  id     String             @id @default(uuid())
  eventId String
  userId  String
  status  RegistrationStatus @default(PENDING)

  // Payment info (for paid events)
  paymentStatus   PaymentStatus?
  stripeSessionId String? // Checkout session ID
  stripeSubId     String? // Subscription ID (for recurring)

  // Timestamps
  registeredAt DateTime  @default(now())
  confirmedAt  DateTime?
  cancelledAt  DateTime?
  cancelReason String?   @db.Text

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId]) // One registration per event per user
  @@index([eventId, status])
  @@index([userId])
  @@map("event_registrations")
}

/// Waitlist for full events
model WaitlistEntry {
  id      String         @id @default(uuid())
  eventId String
  userId  String
  email   String // Denormalized for faster email sending
  position Int           // Queue position (1 = first in line)
  status  WaitlistStatus @default(WAITING)

  // Offer tracking
  offeredAt   DateTime? // When spot was offered
  expiresAt   DateTime? // Deadline to accept offer (e.g., 48 hours)
  respondedAt DateTime? // When user responded

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId]) // One waitlist entry per event per user
  @@index([eventId, status, position]) // For efficient queue processing
  @@map("waitlist")
}

// ============================================================================
// CONTENT DOMAIN
// ============================================================================

/// News articles
model Article {
  id            String    @id @default(uuid())
  title         String
  slug          String    @unique
  excerpt       String?   @db.VarChar(500) // For list views
  content       String    @db.Text // TipTap HTML
  featuredImage String? // Supabase Storage URL
  authorId      String
  status        String    @default("DRAFT") // DRAFT, PUBLISHED, ARCHIVED
  isActive      Boolean   @default(true)
  publishedAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // SEO
  metaTitle       String? @db.VarChar(60)
  metaDescription String? @db.VarChar(160)

  author User @relation("AuthoredArticles", fields: [authorId], references: [id])

  @@index([status, publishedAt])
  @@index([isActive])
  @@index([slug])
  @@map("articles")
}

/// Static CMS pages (About, Contact, etc.)
model StaticPage {
  id      String @id @default(uuid())
  title   String
  slug    String @unique // "about", "contact", "privacy-policy"
  content String @db.Text // TipTap HTML

  // Navigation
  showInNav Boolean @default(false)
  navOrder  Int     @default(0)
  parentId  String? // For nested pages (future)

  // SEO
  metaTitle       String? @db.VarChar(60)
  metaDescription String? @db.VarChar(160)

  // Status
  isPublished Boolean @default(false)

  // Audit
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  createdBy User @relation("CreatedPages", fields: [createdById], references: [id])

  @@index([isPublished])
  @@index([showInNav, navOrder])
  @@map("static_pages")
}

// ============================================================================
// PAYMENT DOMAIN
// ============================================================================

/// Payment records (all Stripe transactions)
model Payment {
  id              String        @id @default(uuid())
  userId          String
  type            PaymentType
  amount          Decimal       @db.Decimal(10, 2)
  currency        String        @default("USD")
  stripePaymentId String        @unique // Stripe PaymentIntent or Subscription ID
  stripeSessionId String? // Checkout Session ID
  status          PaymentStatus @default(PENDING)

  // Contextual data
  metadata Json? // {membershipTypeId, eventId, etc.}

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([stripePaymentId])
  @@index([status])
  @@map("payments")
}

// ============================================================================
// MEDIA DOMAIN
// ============================================================================

/// Media uploads tracking
model Media {
  id           String @id @default(uuid())
  fileName     String // Generated unique filename
  originalName String // Original uploaded filename
  fileSize     Int // Bytes
  mimeType     String // "image/jpeg", "image/png", etc.
  url          String // Full Supabase Storage URL
  bucket       String @default("public") // Supabase bucket name

  // Usage tracking
  entityType String? // "event", "article", "page", "profile"
  entityId   String? // ID of the related entity

  // Audit
  uploadedById String
  createdAt    DateTime @default(now())

  uploadedBy User @relation("UploadedByUser", fields: [uploadedById], references: [id])

  @@index([entityType, entityId])
  @@index([uploadedById])
  @@map("media")
}

// ============================================================================
// AUDIT & COMPLIANCE
// ============================================================================

/// Audit log for tracking all important actions
model AuditLog {
  id         String  @id @default(uuid())
  userId     String? // Null for system actions
  action     String // CREATE, UPDATE, DELETE, APPROVE, LOGIN, ROLE_CHANGE, etc.
  entityType String // User, Event, Membership, Article, etc.
  entityId   String? // ID of affected entity

  // Change tracking
  oldValue Json? // Previous state
  newValue Json? // New state

  // Request context
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  user User? @relation("PerformedByUser", fields: [userId], references: [id])

  @@index([entityType, entityId])
  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}
